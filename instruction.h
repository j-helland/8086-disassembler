#ifndef PERFAWARE_INSTRUCTION_H
#define PERFAWARE_INSTRUCTION_H

#include <vector>

#include "types.h"

/** Parsed representation of an ASM 8086 instruction.
 */
struct instruction_t {
  // Operation that the instruction should perform.
  op_t  opcode;

  /* instruction_t mode.
   * <p> Dictates whether the instruction involves memory or registers, and whether the reg field is displaced.
   * <p> Dictates whether the displacement field is byte or word length.
   */
  mod_t mod;

  // instruction_t register field. This could be either src or dst depending on the D bit.
  u8 reg;

  // Register/memory field. This could be either the src or dst depending on the D bit.
  u8 rm;

  union {
    /* W bit. Specifies whether this is a byte or word operation.
     * <p>- Dictates whether registers are half or full width.
     * <p>- Dictates whether the data field is byte or word length.
     */
    bool wbit;

    /*
     * Z bit.
     * <p> true: repeat/loop while zero flag is clear
     * <p> false: repeat/loop while zero flag is set
     */
    bool zbit;
  };

  union {
    /* D bit. Specifies the "direction" of the operation.
     * <p> true: reg field is the dst.
     * <p> false: reg field is the src.
     */
    bool dbit;

    /*
     * V bit.
     * <p> true: shift/rotate count is specified in CL register.
     * <p> false: shift/rotate count is 1.
     */
    bool vbit;
  };

  union {
    // Displacement data. Used for calculating an address offset. Could be byte or word length depending on the mod field.
    i16 disp;

    // Memory address (offset from 0).
    u16 addr;
  };

  // Data for use in immediate-mode. Could be signed.
  u16 data;

  // Parsing metadata fields
  u8 bytes_read = 0;
  bool is_labeled = false;
  size_t label = 0;
  size_t jump_target = 0;
};

class instruction_stream {
  using iterator_t = std::vector<instruction_t>::iterator;
  using const_iterator_t = std::vector<instruction_t>::const_iterator;

public:
  iterator_t begin() { return _stream.begin(); }
  iterator_t end() { return _stream.end(); }
  const_iterator_t cbegin() { return _stream.cbegin(); }
  const_iterator_t cend() { return _stream.cend(); }

  void push_back(instruction_t &&instr) {
    if (is_conditional_jump_instr(instr)) _jumps.push_back(_stream.size());
    _stream.push_back(instr);
  }

  /**
   * Iterates through all jump instructions observed during push_back operations and assigns labels to each distinct
   * jump target. Jump instructions are processed in FIFO order for purposes of enumerating labels.
   *
   * <p> This method is idempotent.
   *
   * <p>This method has multiple side-effects and should only be used after an entire file has been first-pass parsed:
   * <p>1. Parsed instructions in the underlying instruction container are assigned labels if they are determined to be jump targets.
   * <p>2. Clears the observed jump instructions. This means subsequent calls are no-ops.
   *
   * @throws std::out_of_range When a jump would land at a misaligned address with respect to the instruction stream.
   */
  void process_jumps() {
    if (_jumps.empty()) return;

    // Track labels.
    size_t next_label = 0;

    // Sentinel instruction. Handles case where last instruction is a jump, avoiding undefined behavior.
    _stream.push_back({
                        .bytes_read = _stream.back().bytes_read,
                      });
    // Use this lambda to ensure no intermediate state is leaked.
    const auto cleanup = [&](){
      _stream.pop_back();
      _jumps.clear();
    };

    for (size_t jidx : _jumps) {
      // Walk through the instruction stream until the jump target is found. A label will be assigned if one does not
      // exist already.
      instruction_t jump = _stream[jidx];
      const int direction = ((i8)jump.data > 0) ? 1 : -1;
      // Label position in the byte sequence is the start of the following instruction.
      size_t sidx = jidx + 1;
      for(
        size_t label_offset = abs((i8)jump.data);
        label_offset != 0;
        sidx += direction
        ) {
        // This protects from overflow. Jumps should always be aligned with the byte stream. If they aren't, it's likely
        // that the byte sequence was not generated by an ASM 8086 compliant compiler.
        if (_stream[sidx].bytes_read > label_offset) {
          cleanup();
          printf(
            "[offset] %d [sidx] %zu [label_offset] %zu [bytes_read] %d\n",
            (i8)jump.data, sidx, label_offset, _stream[sidx].bytes_read);
          throw std::out_of_range(
            "Jump target offset is not aligned with the byte stream. Binary may not have been compiled correctly.");
        }
        label_offset -= _stream[sidx].bytes_read;
      }

      if (_stream[sidx].is_labeled) {
        // This position has already been labeled.
        _stream[jidx].jump_target = _stream[sidx].label;
        continue;
      }
      // Create a new label.
      _stream[sidx].is_labeled = true;
      _stream[sidx].label = next_label++;
      _stream[jidx].jump_target = _stream[sidx].label;
    }

    cleanup();
  }

private:
  /** holds the instructions */
  std::vector<instruction_t> _stream;

  /** mark the indices of all jump instructions encountered in the stream */
  std::vector<size_t> _jumps;

  bool is_conditional_jump_instr(const instruction_t &instr) {
    switch (instr.opcode) {
      case JE:
      case JL:
      case JLE:
      case JB:
      case JBE:
      case JP:
      case JO:
      case JS:
      case JNE:
      case JNL:
      case JNLE:
      case JNB:
      case JNBE:
      case JNP:
      case JNO:
      case JNS:
      case LOOP:
      case LOOPZ:
      case LOOPNZ:
      case JCXZ:
        return true;

      default:
        return false;
    }
  }
};

#endif //PERFAWARE_INSTRUCTION_H
